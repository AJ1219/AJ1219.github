<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>GO第一课 | Abel-Johnson's BLOG</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GO第一课</h1><a id="logo" href="/blog/.">Abel-Johnson's BLOG</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GO第一课</h1><div class="post-meta">2019-11-12</div><div class="post-content"><p>[TOC]</p>
<h2><span id="安装与配置">安装与配置</span></h2><h3><span id="换源">换源</span></h3><p>1.13 以上的 go:支持全局 go 代理<br><code>go env -w GOPROXY=https://goproxy.cn,direct</code></p>
<ol>
<li>换源以后,所有包都会走代理, 有些包是自己引入的第三方或者自建的, 走代理的话有时会超时, 导致安装不了, 所以可以过滤不想走代理的域名(也叫私有域名)<code>go env -w GOPRIVATE=&quot;*.gitlab.com&quot;</code></li>
</ol>
<h3><span id="升级-go-两种方法">升级 GO, 两种方法</span></h3><ol>
<li><code>brew upgrade go</code>有点慢</li>
<li>官网直接下载安装包, 会覆盖安装</li>
</ol>
<h3><span id="vscode-配置">vscode 配置</span></h3><ol>
<li>下载 go 插件</li>
<li>cmd+shift+P, 框里输入 go: install/update, 全选安装(把所有用到的工具都装好)</li>
<li><p>配置里加上</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"go.formatTool": "goimports",</span><br><span class="line">"prettier.disableLanguages": [</span><br><span class="line">  "vue",</span><br><span class="line">  <span class="string">"go"</span></span><br><span class="line">],</span><br><span class="line">"go.useLanguageServer": true,</span><br><span class="line">"editor.formatOnSave": true,</span><br><span class="line">"editor.formatOnSaveTimeout": 2500,</span><br><span class="line">"go.coverOnTestPackage": false,</span><br><span class="line">"go.lintOnSave": "off",</span><br><span class="line">"go.lintTool": "golangci-lint",</span><br><span class="line">"go.vetOnSave": "off",</span><br><span class="line">"gopls": &#123;</span><br><span class="line">    "completeUnimported": true  // 不导入就可以用一些内置包的api, 然后就可以自动导入了, 比如直接fmt.就会有提示, 然后保存就会自动把import语句加进去</span><br><span class="line">&#125;,</span><br><span class="line">"go.buildOnSave": "off",</span><br></pre></td></tr></table></figure>
</li>
<li><p>debug 运行服务时, vscode 为例 配置 json</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 使用 IntelliSense 了解相关属性。</span><br><span class="line">  // 悬停以查看现有属性的描述。</span><br><span class="line">  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  "version": "0.2.0",</span><br><span class="line">  "configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Launch"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"go"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"mode"</span>: <span class="string">"debug"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;"</span>,</span><br><span class="line">      <span class="attr">"env"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"args"</span>: [<span class="string">"-env"</span>, <span class="string">"dev"</span>] // 这个很重要 不同的项目有不同的参数约定</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="go-的基础">GO 的基础</span></h2><ol>
<li>发请求的时候, 如何打断点(或者可以试试):<ol>
<li>debug 模式把服务跑起来</li>
</ol>
</li>
<li>跳转不畅<ol>
<li>包结构构建起来就没问题了</li>
</ol>
</li>
<li>* &amp; 地址传值… 1.</li>
<li>继承, 组合 1.</li>
<li><p>数据类型</p>
<ol>
<li><code>b bool := true</code></li>
<li>数字类型<ol>
<li>int<ol>
<li>uint/int 8/16/32/64</li>
<li>这里有个小知识点: 有符号位的算法是: 第一位是符号位, 0 是正数, 1 是负数, 正数的值是其余位正常算, 负数的值是所有位取反后加一后的值, 所以举个例子, int8 的范围应该是: 01111111(+(2^7-1)=+127) ~ 10000000(-(2^7)=-128)</li>
</ol>
</li>
<li>float32 / float64 /complex 64/128</li>
<li>其他: byte≈uint8 rune≈int32 uint/int:32 位或者 64 位 uintptr(无符号整型存指针)</li>
</ol>
</li>
<li>字符串,格式化输出<ul>
<li>%v    按值的本来值输出</li>
<li>%+v    在 %v 基础上，对结构体字段名和值进行展开</li>
<li>%#v    输出 Go 语言语法格式的值</li>
<li>%T    输出 Go 语言语法格式的类型和值</li>
<li>%%    输出 % 本体</li>
<li>%b    整型以二进制方式显示</li>
<li>%o    整型以八进制方式显示</li>
<li>%d    整型以十进制方式显示</li>
<li>%x    整型以十六进制方式显示</li>
<li>%X    整型以十六进制、字母大写方式显示</li>
<li>%U    Unicode 字符</li>
<li>%f    浮点数</li>
<li>%p    指针，十六进制方式显示</li>
<li>%s: 普通字符串</li>
<li>%q: 引号包含字符串</li>
<li>%x, %o, %b: 十六进制，8进制，2进制</li>
<li>%t: bool值</li>
</ul>
</li>
<li><p>其他类型(派生类型)</p>
<ol>
<li>指针(pointer)</li>
<li><p>数组</p>
<ol>
<li>必须相同类型</li>
<li><code>var arr [10]int</code></li>
<li>赋值 <code>= [10]int{1,2,3,4}</code></li>
<li>做函数参数: <code>([]int arr)</code></li>
<li>slice(切片)</li>
<li><code>var slice []int</code></li>
<li>make([]int, len, cap)函数创建切片,</li>
<li>赋值<code>=数组变量[10:20]</code></li>
<li><code>arr[0:2]</code></li>
</ol>
</li>
<li><p>struct(结构体)</p>
<ol>
<li>定义: 不同类型数据集合(类似对象)</li>
<li>定义 type xxx struct {xxxxx xxxx}</li>
<li>使用 xx:=xxx {a,b…}</li>
<li>标签, 每行后可以有标签,通过反射可以拿到, 形如: <code>&quot;the name of student&quot;</code>;<code>\</code>json:”name”``</li>
</ol>
</li>
<li><p>channel, 并发时多线程通信, <code>ch:=make(chan int)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">// 并把值赋给 v</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数</p>
</li>
<li><p>interface (接口)</p>
<ol>
<li>所有共性的方法定义到一起</li>
<li>类似类 class</li>
<li><p>方便理解</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years)"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">"Arthur Dent"</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">"Zaphod Beeblebrox"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li>var countryCapitalMap map[string]string /<em>创建集合 </em>/</li>
<li>countryCapitalMap = make(map[string]string)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>变量声明不赋值,默认值:</p>
<ol>
<li>数值 0</li>
<li>string””</li>
<li>布尔 false</li>
<li>指针/数组/map/chan/func/interface(比如 error) 都是 nil</li>
</ol>
</li>
<li><p><code>:=</code>只能在函数体中出现; 左边一定要至少有一个未声明过的变量</p>
</li>
<li><p>类型</p>
<ol>
<li>值类型<ol>
<li>变量指向值本身</li>
<li>例: 数值, 布尔值, 字符串这样的基本类型</li>
<li>值类型的变量在赋值给新变量的时候, 是拷贝了一个值</li>
<li>可以通过&amp;xxx 来拿到内存地址, 值类型存在栈中(stack)</li>
</ol>
</li>
<li>引用类型<ol>
<li>存一些复杂的数据</li>
<li>变量存的是内存地址(指针)</li>
</ol>
</li>
</ol>
</li>
<li><p>常量</p>
<ol>
<li>只能是字符串 数字 布尔值</li>
<li>也可以用表达式,但是处理函数必须是内置函数</li>
<li><p>实现接口以后, 就可以被别的逻辑隐形调用, 也就是说, 有别的逻辑依赖这个接口, 新的结构实现这个接口以后 就可以直接使用已有的某些api(隐形支持了这个api的调用)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">"abc"</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a) <span class="comment">// 应该是用来查看占用内存大小的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>iota 可被编译器修改的常量, 逐行编译的时候,会不停的变化, const 出现初始化为 0 每新出现一个常量声明 iota+=1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">b <span class="comment">//1</span></span><br><span class="line">c <span class="comment">//2</span></span><br><span class="line">d = <span class="string">"ha"</span> <span class="comment">//独立值，iota += 1</span></span><br><span class="line">e <span class="comment">//"ha" iota += 1</span></span><br><span class="line">f = <span class="number">100</span> <span class="comment">//iota +=1</span></span><br><span class="line">g <span class="comment">//100 iota +=1</span></span><br><span class="line">h = <span class="literal">iota</span> <span class="comment">//7,恢复计数</span></span><br><span class="line">i <span class="comment">//8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>关系运算符只能比较布尔值</p>
</li>
<li>位运算符很有意思, 按位逐个比较产生最后的值(用的时候查就可以)</li>
<li><p>* \&amp;</p>
<ol>
<li>\&amp;返回变量内存地址</li>
<li>*指针变量, 可解析地址为变量值</li>
</ol>
</li>
<li><p>条件语句: go 没有三目; select 类似 switch, 会随机执行一个 case</p>
</li>
<li>函数 vs 方法: 一个方法就是包含了接受者的函数<a href="https://www.runoob.com/go/go-method.html" target="_blank" rel="noopener">https://www.runoob.com/go/go-method.html</a></li>
<li>类型转换<ol>
<li><code>type_name(expression)</code></li>
</ol>
</li>
</ol>
<h3><span id="一些困惑">一些困惑</span></h3><ol>
<li>为什么有些地方使用<code>_.e = xxx</code><ol>
<li><em>\</em>是用来抛弃值的_, 因为用不到, 但是返回了, 而且是第一位, go 要求只要取出来必须使用, 所以用来解决这个问题</li>
</ol>
</li>
<li>字符串格式化输出 <code>fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s)</code></li>
<li>struct</li>
<li>interface</li>
<li>main 包</li>
<li>文件名, 文件夹名, 包名没有直接关系</li>
<li>同一个文件夹下的文件只能同一个包名</li>
<li>直接调函数名只能是当前包(暂时是所在文件夹)的方法</li>
<li>包, 层,的概念</li>
<li>gin 和 MVC</li>
<li>gin 的 基本结构</li>
<li>常用 api</li>
<li>fmt.print<ol>
<li>fmt.print(“123\n”) 等价于 fmt.println(“123”)</li>
</ol>
</li>
<li>标识符大写开头代表是公开(public)方法, 这种写法叫做导出(小写就私有 protected)</li>
</ol>
<h3><span id="支持多返回值-支持命名返回值">支持多返回值、支持命名返回值</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumProductDiff</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// 多返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i+j, i\*j, i-j</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// 命名返回</span></span><br><span class="line"></span><br><span class="line">x = sum \* <span class="number">4</span> / <span class="number">9</span></span><br><span class="line"></span><br><span class="line">y = sum - x</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者：laigw<br>链接：<a href="https://www.jianshu.com/p/7d8c98e7dee6" target="_blank" rel="noopener">https://www.jianshu.com/p/7d8c98e7dee6</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>如果方法是公开访问的，建议最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<h3><span id="不定参数">不定参数</span></h3><p>func myfunc (arg …int) {}</p>
<p>arg …int 告诉 Go 这个函数接受不定数量的参数。注意，这些参数的类型全部是 int。arg 是一个 int 的 slice</p>
<h2><span id="传值与传指针">传值与传指针</span></h2><p>// 简单的一个函数，实现了函数+1 的操作</p>
<p>func add1(a *int) int {</p>
<p><em>a = </em>a + 1    // 改变了 a 值</p>
<p>return *a    // 返回新值</p>
<p>}</p>
<p>func main () {</p>
<p>x := 3</p>
<p>fmt.Println(“x=”, x)    // 输出”x=3”</p>
<p>x1 := add1(&amp;x)</p>
<p>fmt.Println(“x+1=”, x1)    // 输出”x+1=4”</p>
<p>fmt.Println(“x=”, x)    // 输出”x=4”</p>
<p>}</p>
<p>这样，我们就达到了修改 x 的目的。</p>
<p>那么到底传指针有什么好处呢？</p>
<p>1）传指针使得多个函数能操作同一个对象；</p>
<p>2）传指针比较轻量级 (8bytes)，只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次 copy 上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。</p>
<p>3）Go 语言中 channel，slice，map 这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变 slice 的长度，则仍需要取地址传递指针）</p>
<p>作者：laigw<br>链接：<a href="https://www.jianshu.com/p/7d8c98e7dee6" target="_blank" rel="noopener">https://www.jianshu.com/p/7d8c98e7dee6</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2><span id="函数作为值-类型">函数作为值、类型</span></h2><p>在 Go 中函数也是一种变量，我们可以通过 type 来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型。</p>
<p>type typeName func(input1 inputType1, input2 inputType2 [, …]) (result1 resultType1 [, …])</p>
<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递。</p>
<p>type testInt func(int) bool    // 声明了一个函数类型</p>
<p>func isOdd(integer int) bool {</p>
<p>if integer%2 == 0 {</p>
<p>return false</p>
<p>}</p>
<p>return true</p>
<p>}</p>
<p>func isEven(integer int) bool {</p>
<p>if integer%2 == 0 {</p>
<p>return true</p>
<p>}</p>
<p>return false</p>
<p>}</p>
<p>// 声明的函数类型作为一个参数</p>
<p>func filter(slice []int, f testInt) []int {</p>
<p>var result []int</p>
<p>for _, value := range slice {</p>
<p>if f(value) {</p>
<p>result = append(result, value)</p>
<p>}</p>
<p>return result</p>
<p>}</p>
<p>func main() {</p>
<p>slice := []int {1,2,3,4,5,6,7}</p>
<p>fmt.Println(“slice=”, slice)</p>
<p>odd := filter(slice, isOdd)    // 函数作为值传递</p>
<p>fmt.Println(“odd elements of slice are:”, odd)</p>
<p>even := filter(slice, isEven)    // 函数作为值传递</p>
<p>fmt.Println(“even elements of slice are:”, even)</p>
<p>}</p>
<p>函数当做值和类型在我们写一些通用接口的时候非常有用，通过上面例子我们看到 testInt 这个类型是一个函数类型，然后两个 filter 函数的参数和返回值与 testInt 类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。</p>
<p>作者：laigw<br>链接：<a href="https://www.jianshu.com/p/7d8c98e7dee6" target="_blank" rel="noopener">https://www.jianshu.com/p/7d8c98e7dee6</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<ol>
<li>go module 才能模块化开发</li>
</ol>
<p><code>go mod init 项目名</code></p>
<ol>
<li>单元测试</li>
</ol>
<p>每个测试文件必须以 _test.go 结尾，不然 go test 不能发现测试文件<br>每个测试文件必须导入 testing 包<br>功能测试函数必须以 Test 开头，然后一般接测试函数的名字，这个不强求</p>
<p>关于 go test 命令<br>go test [-c][-i] [build flags][packages] [flags for test binary]<br>参数解读<br>-c : 编译 go test 成为可执行的二进制文件，但是不运行测试。</p>
<p>-i : 安装测试包依赖的 package，但是不运行测试。</p>
<p>关于 build flags，调用 go help build，这些是编译运行过程中需要使用到的参数，一般设置为空</p>
<p>关于 packages，调用 go help packages，这些是关于包的管理，一般设置为空</p>
<p>关于 flags for test binary，调用 go help testflag，这些是 go test 过程中经常使用到的参数</p>
<p>-test.v : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</p>
<p>-test.run pattern: 只跑哪些单元测试用例</p>
<p>-test.bench patten: 只跑那些性能测试用例</p>
<p>-test.benchmem : 是否在性能测试的时候输出内存情况</p>
<p>-test.benchtime t : 性能测试运行的时间，默认是 1s</p>
<p>-test.cpuprofile cpu.out : 是否输出 cpu 性能分析文件</p>
<p>-test.memprofile mem.out : 是否输出内存性能分析文件</p>
<p>-test.blockprofile block.out : 是否输出内部 goroutine 阻塞的性能分析文件</p>
<p>-test.memprofilerate n : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是 profile 中一个 sample 代表的内存大小。默认是设置为 512 * 1024 的。如果你将它设置为 1，则每分配一个内存块就会在 profile 中有个打点，那么生成的 profile 的 sample 就会非常多。如果你设置为 0，那就是不做打点了。</p>
<p>你可以通过设置 memprofilerate=1 和 GOGC=off 来关闭内存回收，并且对每个内存块的分配进行观察。</p>
<p>-test.blockprofilerate n: 基本同上，控制的是 goroutine 阻塞时候打点的纳秒数。默认不设置就相当于-test.blockprofilerate=1，每一纳秒都打点记录一下</p>
<p>-test.parallel n : 性能测试的程序并行 cpu 数，默认等于 GOMAXPROCS。</p>
<p>-test.timeout t : 如果测试用例运行时间超过 t，则抛出 panic</p>
<p>-test.cpu 1,2,4 : 程序运行在哪些 CPU 上面，使用二进制的 1 所在位代表，和 nginx 的 nginx_worker_cpu_affinity 是一个道理</p>
<p>-test.short : 将那些运行时间较长的测试用例运行时间缩短</p>
<p>作者：MicoCube<br>链接：<a href="https://www.jianshu.com/p/cb47fe8f295c" target="_blank" rel="noopener">https://www.jianshu.com/p/cb47fe8f295c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>经过上面简单的例子的演示和操作，现在我们大概可以了解到路由需要传入两个参数，一个为路径，另一个为路由执行的方法，我们叫做它处理器 Handler ，而且，该参数是可变长参数。也就是说，可以传入多个 handler，形成一条 handler chain 。</p>
<p>====</p>
<p>结论已经很明显，string(int) 会将整数直译为 ASCII 编码，<br>而 strconv.Itoa(int) 才会转换成对应的数字字符在 ASACII 编码。</p>
<p>int to a(a 代表字符串)</p>
<p>静态资源(css)需要两个要素 1. router.static 2. link 标签引入</p>
<p>a = <em>b 中 </em>b 基础地址的值 就相当于 b 本身的值</p>
<p>a=&amp;b &amp;b 相当于指针的地址，是个指针</p>
</div><div class="tags"><a href="/blog/tags/Go/"><i class="fa fa-tag"></i>Go</a></div><div class="post-nav"><a class="pre" href="/blog/2019/11/13/GO第二课/">GO第二课</a><a class="next" href="/blog/2019/09/10/gitbook导出电子书/">gitbook导出电子书</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://aj1219.github.io/blog"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/React/" style="font-size: 15px;">React</a> <a href="/blog/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/blog/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/blog/tags/前端/" style="font-size: 15px;">前端</a> <a href="/blog/tags/Go/" style="font-size: 15px;">Go</a> <a href="/blog/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/blog/tags/Git/" style="font-size: 15px;">Git</a> <a href="/blog/tags/JQuery/" style="font-size: 15px;">JQuery</a> <a href="/blog/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/blog/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/blog/tags/管理/" style="font-size: 15px;">管理</a> <a href="/blog/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/blog/tags/个人成长/" style="font-size: 15px;">个人成长</a> <a href="/blog/tags/面试/" style="font-size: 15px;">面试</a> <a href="/blog/tags/Aha/" style="font-size: 15px;">Aha</a> <a href="/blog/tags/技术参考/" style="font-size: 15px;">技术参考</a> <a href="/blog/tags/CSS3/" style="font-size: 15px;">CSS3</a> <a href="/blog/tags/电子书/" style="font-size: 15px;">电子书</a> <a href="/blog/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/blog/tags/go/" style="font-size: 15px;">go</a> <a href="/blog/tags/编程作业/" style="font-size: 15px;">编程作业</a> <a href="/blog/tags/https/" style="font-size: 15px;">https</a> <a href="/blog/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/blog/tags/Node/" style="font-size: 15px;">Node</a> <a href="/blog/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/blog/tags/shell/" style="font-size: 15px;">shell</a> <a href="/blog/tags/Unix/" style="font-size: 15px;">Unix</a> <a href="/blog/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/blog/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/blog/tags/计算机基础知识/" style="font-size: 15px;">计算机基础知识</a> <a href="/blog/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/blog/tags/心理学/" style="font-size: 15px;">心理学</a> <a href="/blog/tags/生活/" style="font-size: 15px;">生活</a> <a href="/blog/tags/网络/" style="font-size: 15px;">网络</a> <a href="/blog/tags/人生/" style="font-size: 15px;">人生</a> <a href="/blog/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/blog/tags/Apache/" style="font-size: 15px;">Apache</a> <a href="/blog/tags/坑/" style="font-size: 15px;">坑</a> <a href="/blog/tags/小程序/" style="font-size: 15px;">小程序</a> <a href="/blog/tags/兼容性/" style="font-size: 15px;">兼容性</a> <a href="/blog/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/blog/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/blog/tags/Ping/" style="font-size: 15px;">Ping</a> <a href="/blog/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/blog/tags/逻辑/" style="font-size: 15px;">逻辑</a> <a href="/blog/tags/redux/" style="font-size: 15px;">redux</a> <a href="/blog/tags/代码规范/" style="font-size: 15px;">代码规范</a> <a href="/blog/tags/webpack3/" style="font-size: 15px;">webpack3</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2021/08/02/Golang错误vs异常/">Golang错误vs异常</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/06/07/熟练ssh/">熟练ssh</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/04/14/周日消费指南/">幸福人生</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/04/09/物理像素、逻辑像素、CSS像素、PPI、设备像素比是什么/">物理像素、逻辑像素、CSS像素、PPI、设备像素比是什么</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/08/重新定义管理/">重新定义管理</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/18/OKR黄勇笔记笔记/">OKR黄勇笔记笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/18/自定义角色感/">自定义角色感</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/01/06/hello-Hexo/">Hello Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/25/Linux入门/">Linux入门</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/25/Nginx入门/">Nginx入门</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/blog/." rel="nofollow">Abel-Johnson's BLOG.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script></div></body></html>